; Generated from CVars_latest_.json at 2025-12-21 18:35:42
; Entries: 69

r.NGX.Automation.Enable=false                                                                                 ;    Enable automation for NGX DLSS image quality and performance evaluation. (default = 0)\n type=Boolean flags=RenderThreadSafe
r.NGX.Automation.NonGameViews=0                                                                               ;    Enable NGX DLSS image quality and performance automation for non-game views. (default = 0). \n type=Int32 flags=RenderThreadSafe
r.NGX.Automation.ViewIndex=0                                                                                  ;    Select which view to use with NGX DLSS image quality and performance automation. (default = 0). \n type=Int32 flags=RenderThreadSafe
r.NGX.BinarySearchOrder=0                                                                                     ;    0: automatic: (default)\n   use custom binaries from project and launch folder $(ProjectDir)/Binaries/ThirdParty/NVIDIA/NGX/$(Platform) if present\n   fallback to generic binaries from plugin folder\n1: force generic binaries from plugin folder, fail if not found\n2: force custom binaries from project or launch folder, fail if not found\n3: force generic development binaries from plugin folder, fail if not found. This is only supported in non-shipping build configurations\n type=Int32 flags=SetByConstructor
r.NGX.DLSS.AutoExposure=0                                                                                     ;    0: Use the engine-computed exposure value for input images to DLSS - in some cases this may reduce artifacts\n1: Enable DLSS internal auto-exposure instead of the application provided one (default)\n type=Int32 flags=RenderThreadSafe|SetByGameSetting|SetBySystemSettingsIni
r.NGX.DLSS.BiasCurrentColorMask=0                                                                             ;    Enable/Disable support for BiasCurrentColorMask. type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.BiasCurrentColorMaskStencilValue=-1                                                                ;    The value that would be considered as Bias Color in the custom depth stencil buffer, Must not be set to 0!\n -1: Use project settings value\n>=1: Use CVar Value as stencil value, Note: must be positive, non-zero.\n type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.BuiltInDenoiserOverride=-1                                                                         ;    Change what happens to the built-in denoisers\n-1: automatic, depending on r.NGX.DLSS.DenoiserMode (default)\n 0: skip all built-in denoising\n 1: use built-in denoising\n type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.DenoiserMode=0                                                                                     ;    Configures how DLSS denoises\n0: off, no denoising (default)\n1: DLSS-RR enabled\n type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.DilateMotionVectors=1                                                                              ;    0: pass low resolution motion vectors into DLSS-SR\n 1: pass dilated high resolution motion vectors into DLSS-SR. This can help with improving image quality of thin details. (default) type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.DisableSubsurfaceCheckerboard=true                                                                 ;    Skip checkerboard decoding for GBuffer Resolve Pass\n type=Boolean flags=RenderThreadSafe
r.NGX.DLSS.Enable=1                                                                                           ;    Enable/Disable DLSS entirely. type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.EnableAlphaUpscaling=-1                                                                            ;    Enables Alpha channel upscaling\nNote: r.PostProcessing.PropagateAlpha MUST be enabled for this feature to work.\n -1: based of r.PostProcessing.PropagateAlpha (default);\n  0: disabled;\n  1: enabled.\n type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.FeatureCreationNode=-1                                                                             ;    Determines which GPU the DLSS feature is getting created on\n-1: Create on the GPU the command list is getting executed on (default)\n 0: Create on GPU node 0 \n 1: Create on GPU node 1 \n type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.FeatureVisibilityMask=-1                                                                           ;    Determines which GPU the DLSS feature is visible to\n-1: Visible to the GPU the command list is getting executed on (default)\n 1: visible to GPU node 0 \n 2:  visible to GPU node 1 \n 3:  visible to GPU node 0 and GPU node 1\n type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.MinimumWindowsBuildVersion=16299                                                                   ;    Sets the minimum Windows 10 build version required to enable DLSS. (default: 16299 for v1709, Windows 10 Fall 2017 Creators Update 64-bit) type=Int32 flags=SetByConstructor
r.NGX.DLSS.Preset=10                                                                                          ;    DLSS-SR/DLAA preset setting. Allows selecting a different DL model than the default\n  0: Use default preset or ini value\n  1: Force preset A\n  2: Force preset B\n  3: Force preset C\n  4: Force preset D\n  5: Force preset E\n  6: Force preset F\n  7: Force preset G\n  8,9: Unsupported preset\n 10: Force preset J\n 11: Force preset K\n 12: Force preset L\n 13: Force preset M\n 14: Force preset N\n 15: Force preset O type=Int32 flags=RenderThreadSafe|SetByGameSetting|SetBySystemSettingsIni
r.NGX.DLSS.Reflections.TemporalAA=1                                                                           ;    Apply a temporal AA pass on the denoised reflections type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.ReleaseMemoryOnDelete=1                                                                            ;    Enabling/disable releasing DLSS related memory on the NGX side when DLSS features get released.(default=1) type=Int32 flags=RenderThreadSafe
r.NGX.DLSS.WaterReflections.TemporalAA=1                                                                      ;    Apply a temporal AA pass on the denoised water reflections type=Int32 flags=RenderThreadSafe
r.NGX.DLSSRR.Preset=0                                                                                         ;    DLSS-RR/DLAA preset setting. Allows selecting a different DL model than the default\n  0: Use default preset or ini value\n  1: Force preset A\n  2: Force preset B\n  3: Force preset C\n  4: Force preset D\n  5: Force preset E\n  6: Force preset F\n  7: Force preset G\n  8: Force preset H\n  9: Force preset I\n 10: Force preset J\n 11: Force preset K\n 12: Force preset L\n 13: Force preset M\n 14: Force preset N\n 15: Force preset O type=Int32 flags=RenderThreadSafe
r.NGX.Enable=1                                                                                                ;    Whether the NGX library should be loaded. This allow to have the DLSS plugin enabled but avoiding potential incompatibilities by skipping the driver side NGX parts of DLSS. Can also be set on the command line via -ngxenable and -ngxdisable type=Int32 flags=SetByConstructor
r.NGX.Enable.AllowCommandLine=0                                                                               ;    Whether to allow to override r.NGX.Enable with -ngxenable and -ngxdisable type=Int32 flags=SetByConstructor
r.NGX.FramesUntilFeatureDestruction=3                                                                         ;    Number of frames until an unused NGX feature gets destroyed. (default=3) type=Int32 flags=RenderThreadSafe
r.NGX.LogLevel=1                                                                                              ;    Determines the minimal amount of logging the NGX implementation pipes into LogDLSSNGX. Can be overridden by the -NGXLogLevel= command line option\nPlease refer to the DLSS plugin documentation on other ways to change the logging level.\n0: off \n1: on (default)\n2: verbose type=Int32 flags=SetByConstructor
r.NGX.ProjectIdentifier=0                                                                                     ;    0: automatic: (default)\n   use NVIDIA NGX Application ID if non-zero, otherwise use UE Project ID)\n1: force UE Project ID\n2: force NVIDIA NGX Application ID (set via the Project Settings -> NVIDIA DLSS plugin)\n type=Int32 flags=SetByConstructor
r.NGX.RenameNGXLogSeverities=1                                                                                ;    Renames 'error' and 'warning' in messages returned by the NGX log callback to 'e_rror' and 'w_arning' before passing them to the UE log system\n0: off \n1: on, for select messages during initalization (default)\n2: on, for all messages\n type=Int32 flags=SetByConstructor
r.TSR.16BitVALU=1                                                                                             ;    Whether to use 16bit VALU on platform that have bSupportsRealTypes=RuntimeDependent type=Int32 flags=RenderThreadSafe
r.TSR.16BitVALU.AMD=1                                                                                         ;    Overrides whether to use 16bit VALU on AMD desktop GPUs type=Int32 flags=RenderThreadSafe
r.TSR.16BitVALU.Intel=1                                                                                       ;    Overrides whether to use 16bit VALU on Intel desktop GPUs type=Int32 flags=RenderThreadSafe
r.TSR.16BitVALU.Nvidia=0                                                                                      ;    Overrides whether to use 16bit VALU on Nvidia desktop GPUs type=Int32 flags=RenderThreadSafe
r.TSR.AplhaChannel=-1                                                                                         ;    Controls whether TSR should process the scene color's alpha channel.\n -1: based of r.PostProcessing.PropagateAlpha (default);\n  0: disabled;\n  1: enabled.\n type=Int32 flags=RenderThreadSafe
r.TSR.AsyncCompute=2                                                                                          ;    Controls how TSR run on async compute. Some TSR passes can overlap with previous passes.\n 0: Disabled;\n 1: Run on async compute only passes that are completly independent from any intermediary resource of this frame, namely ClearPrevTextures and ForwardScatterDepth passes;\n 2: Run on async compute only passes that are completly independent or only dependent on the depth and velocity buffer which can overlap for instance with translucency or DOF. Any passes on critical path remains on the graphics queue (default);\n 3: Run all passes on async compute; type=Int32 flags=RenderThreadSafe
r.TSR.ForceSeparateTranslucency=1                                                                             ;    Overrides r.SeparateTranslucency whenever TSR is enabled (enabled by default).\n type=Int32 flags=RenderThreadSafe
r.TSR.History.R11G11B10=1                                                                                     ;    Select the bitdepth of the history. r.TSR.History.R11G11B10=1 Saves memory bandwidth that is of particular interest of the TSR's UpdateHistory's runtime performance by saving memory both at previous frame's history reprojection and write out of the output and new history.\nThis optimisation is unsupported with r.PostProcessing.PropagateAlpha=True.\n\nPlease also not that increasing r.TSR.History.ScreenPercentage=200 adds 2 additional implicit encoding bits in the history compared to the TSR.Output's bitdepth thanks to the downscaling pass from TSR history resolution to TSR output resolution. type=Int32 flags=RenderThreadSafe|Scalability|SetByScalability
r.TSR.History.SampleCount=16.0                                                                                ;    Maximum number sample for each output pixel in the history. Higher values means more stability on highlights on static images, but may introduce additional ghosting on firefliers style of VFX. Minimum value supported is 8.0 as TSR was in 5.0 and 5.1. Maximum value possible due to the encoding of the TSR.History.Metadata is 32.0. Defaults to 16.0.\n\nUse "r.TSR.Visualize 0" command to see how many samples where accumulated in TSR history on areas of the screen. type=Float flags=RenderThreadSafe
r.TSR.History.UpdateQuality=0                                                                                 ;    Selects shader permutation of the quality of the update of the history in the TSR HistoryUpdate pass currently driven by the sg.AntiAliasingQuality scalability group. For further details about what each offers, you are invited to look at DIM_UPDATE_QUALITY in TSRUpdateHistory.usf and customise to your need. type=Int32 flags=RenderThreadSafe|Scalability|SetByScalability
r.TSR.LensDistortion=1                                                                                        ;    Whether to apply lens distortion in TSR at runtime (enabled by default, requires r.TSR.Support.LensDistortion enabled at cook time). type=Int32 flags=RenderThreadSafe
r.TSR.RejectionAntiAliasingQuality=0                                                                          ;    Controls the quality of TSR's built-in spatial anti-aliasing technology when the history needs to be rejected. While this may not be critical when the rendering resolution is not much lowered than display resolution, this technic however becomes essential to hide lower rendering resolution rendering because of two reasons:\n - the screen space size of aliasing is inverse proportional to rendering resolution;\n - rendering at lower resolution means need more frame to reach at least 1 rendered pixel per display pixel.\n\nUse "r.TSR.Visualize 6" command to see on screen where the spatial anti-aliaser quicks in green.\n\nBy default, it is only disabled by default in the low anti-aliasing scalability group. type=Int32 flags=RenderThreadSafe|Scalability|SetByScalability
r.TSR.ReprojectionField=0                                                                                     ;    Enables TSR's reprojection field for higher reprojection vector upscale and dilate quality (Enabled by default on high, epic and cinematic anti-aliasing quality).\n\nWhen the reprojection fields is enabled, it dilates the reprojection vector by half spatially anti-aliased rendering pixel from the depth buffer, instead by a full rendering pixel in dilate velocity pass. This allows hide the rendering resolution due whenever velocity buffer ends up extruding some object to edges, for instance when rotating. This come at the cost of spatial anti-aliasing in the DilateVelocity pass as well as an extra dependent texture fetches right at the begining of the HistoryUpdate pass.\n\nThe reprojection field also embeds a jacobian 2x2 matrix for each pixel to have more precise reprojection of the historyfor the display pixels in the rendering pixels. This for instance allows to maintains sharp geometric edges on movements. type=Int32 flags=RenderThreadSafe|Scalability|SetByScalability
r.TSR.ReprojectionField.AntiAliasPixelSpeed=0.125                                                             ;    Defines the output pixel velocity at which point the dilation should be spatial anti-aliased based of the depth buffer to avoid reprojection aliasing by extrusion on fast geometric edges (Default to 0.125, best tuned with r.TSR.Visualize=11). type=Float flags=RenderThreadSafe
r.TSR.Resurrection=0                                                                                          ;    Allows TSR to resurrect previously discarded details from many frames ago.\n\nWhen enabled, the entire frames of the TSR are stored in a same unique Texture2DArray including a configurable number of persistent frame (defined by r.TSR.Resurrection.PersistentFrameCount) that are occasionally recorded (defined by r.TSR.Resurrection.PersistentFrameInterval).\nThen every frame, TSR will attempt to reproject either previous frame, or the oldest persistent frame available based which matches best the current frames. The later option will happen when something previously seen by TSR shows up again (no matter through parallax disocclusion, shading changes, translucent VFX moving) which will have the advantage bypass the need to newly accumulate a second time by simply resurrected the previously accumulated details.\n\nCommand "r.TSR.Visualize 4" too see parts of the screen is being resurrected by TSR in green.\nCommand "r.TSR.Visualize 5" too see the oldest frame being possibly resurrected.\n\nCurrently experimental and disabled by default. type=Int32 flags=RenderThreadSafe|Scalability|SetByScalability
r.TSR.Resurrection.PersistentFrameCount=2                                                                     ;    Configures the number of persistent frame to record in history for futur history resurrection. This will increase the memory footprint of the entire TSR history. Must be an even number greater or equal to 2. (default=2) type=Int32 flags=RenderThreadSafe
r.TSR.Resurrection.PersistentFrameInterval=31                                                                 ;    Configures in number of frames how often persistent frame should be recorded in history for futur history resurrection. This has no implication on memory footprint of the TSR history. Must be an odd number greater or equal to 1. Uses the VisualizeTSR show flag and r.TSR.Visualize=5 to tune this parameter to your content. (default=31) type=Int32 flags=RenderThreadSafe
r.TSR.ShadingRejection.Flickering=0                                                                           ;    Instability in TSR output 99% of the time coming from instability of the shading rejection, for different reasons:\n - One first source of instability is most famously moire pattern between structured geometry and the rendering pixel grid changing every frame due to the offset of the jittering pixel grid offset;\n - Another source of instability can happen on extrem geometric complexity due to temporal history's chicken-and-egg problem that can not be overcome by other mechanisms in place in TSR's RejectHistory pass: how can the history be identical to rendered frame if the amount of details you have in the rendered frame is not in history? how can the history accumulate details if the history is too different from the rendered frame?\n\nWhen enabled, this flickering temporal analysis monitor how the luminance of the scene right before any translucency drawing stored in the TSR.Flickering.Luminance resource how it involves over successive frames. And if it is detected to constantly flicker regularily above a certain threshold defined with this r.TSR.ShadingRejection.Flickering.* cvars, the heuristic attempts to stabilize the image by letting ghost within luminance boundary tied to the amplititude of flickering.\n\nUse "r.TSR.Visualize 7" command to see on screen where this heuristic quicks in orange and red. Pink is where it is disabled.\n\nOne particular caveat of this heuristic is that any opaque geometry with incorrect motion vector can make a pixel look identically flickery quicking this heuristic in and leaving undesired ghosting effects on the said geometry. When that happens, it is highly encourage to verify the motion vector through the VisualizeMotionBlur show flag and how these motion vectors are able to reproject previous frame with the VisualizeReprojection show flag.\n\nThe variable to countrol the frame frequency at which a pixel is considered flickery and needs to be stabilized with this heuristic is defined with the r.TSR.ShadingRejection.Flickering.Period in frames. For instance, a value r.TSR.ShadingRejection.Flickering.Period=3, it means any pixel that have its luminance changing of variation every more often than every frames is considered flickering.\n\nHowever another caveats on this boundary between flickering pixel versus animated pixel is that: flickering happens regardless of frame rate, whereas a visual effects that are/should be based on time and are therefore independent of the frame rate. This mean that a visual effect that looks smooth at 60hz might appear to 'flicker' at lower frame rates, like 24hz for instance.\nTo make sure a visual effect authored by an artists doesn't start to ghost of frame rate, r.TSR.ShadingRejection.Flickering.AdjustToFrameRate is enabled by default such that this frame frequency boundary is automatically when the frame rate drops below a refresh rate below r.TSR.ShadingRejection.Flickering.FrameRateCap.\n\nWhile r.TSR.ShadingRejection.Flickering is controled based of scalability settings turn on/off this heuristic on lower/high-end GPU the other r.TSR.ShadingRejection.Flickering.* can be set orthogonally in the Project's DefaultEngine.ini for a consistent behavior across all platforms.\n\nIt is enabled by default in the anti-aliasing scalability group High, Epic and Cinematic. type=Int32 flags=RenderThreadSafe|Scalability|SetByScalability
r.TSR.ShadingRejection.Flickering.AdjustToFrameRate=1                                                         ;    Whether r.TSR.ShadingRejection.Flickering.Period settings should adjust to frame rate when below r.TSR.ShadingRejection.Flickering.FrameRateCap. Please read r.TSR.ShadingRejection.Flickering's help for further details. (Enabled by default). type=Int32 flags=RenderThreadSafe|Scalability
r.TSR.ShadingRejection.Flickering.FrameRateCap=60.0                                                           ;    Framerate cap in hertz at which point there is automatic adjustment of r.TSR.ShadingRejection.Flickering.Period when the rendering frame rate is lower. Please read r.TSR.ShadingRejection.Flickering's help for further details. (Default to 60hz) type=Float flags=RenderThreadSafe|Scalability
r.TSR.ShadingRejection.Flickering.MaxParallaxVelocity=10.0                                                    ;    Some material might for instance might do something like parallax occlusion mapping such as CitySample's buildings' window's interiors. This often can not render accurately a motion vector of this fake interior geometry and therefore make the heuristic believe it is in fact flickering.\n\nThis variable define the parallax velocity in 1080p pixel at frame rate defined by r.TSR.ShadingRejection.Flickering.FrameRateCap at which point the heuristic should be disabled to not ghost. \n(Default to 10 pixels 1080p).\n type=Float flags=RenderThreadSafe
r.TSR.ShadingRejection.Flickering.Period=2.0                                                                  ;    Periode in frames in which luma oscilations at equal or greater frequency is considered flickering and should ghost to stabilize the image Please read r.TSR.ShadingRejection.Flickering's help for further details. (Default to 3 frames). type=Float flags=RenderThreadSafe
r.TSR.ShadingRejection.SampleCount=2.0                                                                        ;    Maximum number of sample in each output pixel of the history after total shading rejection.\n\nLower values means higher clarity of the image after shading rejection of the history, but at the trade of higher instability of the pixel on following frames accumulating new details which can be distracting to the human eye (Defaults to 2.0). type=Float flags=RenderThreadSafe
r.TSR.ShadingRejection.TileOverscan=3                                                                         ;    The shading rejection run a network of convolutions on the GPU all in single 32x32 without roundtrip to main video memory. However chaining many convlutions in this tiles means that some convolutions on the edge arround are becoming corrupted and therefor need to overlap the tile by couple of padding to hide it. Higher means less prones to tiling artifacts, but performance loss. type=Int32 flags=RenderThreadSafe
r.TSR.Support.LensDistortion=1                                                                                ;    Whether to compile lens distortion support in TSR's shaders (adds the lens distortion LUT in the HistoryUpdate pass in branches that even disabled can add a bit of VALU cost when no lens distortion is used).\n 0: unsupported;\n 1: supported only on desktop (default);\n 2: supported everywhere;\n type=Int32 flags=SetByConstructor
r.TSR.Velocity.WeightClampingPixelSpeed=1.0                                                                   ;    Defines the output pixel velocity at which the the high frequencies of the history get's their contributing weight clamped. It's basically to lerp the effect of r.TSR.Velocity.WeightClampingSampleCount when the pixel velocity get smaller than r.TSR.Velocity.WeightClampingPixelSpeed. (Default = 1.0f). type=Float flags=RenderThreadSafe
r.TSR.Velocity.WeightClampingSampleCount=4.0                                                                  ;    Number of sample to count to in history pixel to clamp history to when output pixel velocity reach r.TSR.Velocity.WeightClampingPixelSpeed. Higher value means higher stability on movement, but at the expense of additional blur due to successive convolution of each history reprojection.\n\nUse "r.TSR.Visualize 0" command to see how many samples where accumulated in TSR history on areas of the screen.\n\nPlease note this clamp the sample count in history pixel, not output pixel, and therefore lower values are by designed less noticeable with higher r.TSR.History.ScreenPercentage. This is done so such that increasing r.TSR.History.ScreenPercentage uniterally & automatically give more temporal stability and maintaining sharpness of the details reprojection at the expense of that extra runtime cost regardless of this setting.\n\nA story telling game might preferer to keep this 4.0 for a 'cinematic look' whereas a competitive game like Fortnite would preferer to lower that to 2.0. (Default = 4.0f). type=Float flags=RenderThreadSafe
r.TSR.WaveOps=1                                                                                               ;    Whether to use wave ops in the shading rejection heuristics to speeds up convolutions.\n\nThe shading rejection heuristic optimisation can be particularily hard for shader compiler and hit bug in them causing corruption/quality loss.\n\nNote this optimisation is currently disabled on SPIRV platforms (mainly Vulkan and Metal) due to 5min+ compilation times in SPIRV backend of DXC which is not great for editor startup. type=Int32 flags=RenderThreadSafe
r.TSR.WaveSize=0                                                                                              ;    Overrides the WaveSize to use.\n 0: Automatic (default);\n 16: WaveSizeOps 16;\n 32: WaveSizeOps 32;\n 64: WaveSizeOps 64;\n type=Int32 flags=RenderThreadSafe
r.TemporalAA.Upscaler=1                                                                                       ;    Choose the upscaling algorithm.\n 0: Forces the default temporal upscaler of the renderer;\n 1: GTemporalUpscaler which may be overridden by a third party plugin (default). type=Int32 flags=RenderThreadSafe
r.Upscale.Quality=0                                                                                           ;    Defines the quality in which ScreenPercentage and WindowedFullscreen scales the 3d rendering.\n 0: Nearest filtering\n 1: Simple Bilinear\n 2: Directional blur with unsharp mask upsample.\n 3: 5-tap Catmull-Rom bicubic, approximating Lanczos 2. (default)\n 4: 13-tap Lanczos 3.\n 5: 36-tap Gaussian-filtered unsharp mask (very expensive, but good for extreme upsampling).\n type=Int32 flags=RenderThreadSafe|Scalability|SetByScalability
r.Upscale.Softness=1.0                                                                                        ;    Amount of sharpening for Gaussian Unsharp filter (r.UpscaleQuality=5). Reduce if ringing is visible\n  1: Normal sharpening (default)\n  0: No sharpening (pure Gaussian). type=Float flags=RenderThreadSafe|Scalability
r.XeSS.AutoExposure=1                                                                                         ;    [default: 1] Use XeSS internal auto exposure. type=Int32 flags=RenderThreadSafe
r.XeSS.Enabled=0                                                                                              ;    [default: 0] Set to 1 to use XeSS instead of TAAU or any other upscaling method. type=Int32 flags=RenderThreadSafe
r.XeSS.Experimental.PreExposure=1                                                                             ;    [default: 1] Whether to enable pre-exposure. It just unifies commands across different Unreal versions. type=Int32 flags=SetByConstructor
r.XeSS.FrameDump.Mode=all                                                                                     ;    DEPRECATED, please use XeSS Inspector tool instead. type=String flags=SetByConstructor
r.XeSS.FrameDump.Path=.                                                                                       ;    DEPRECATED, please use XeSS Inspector tool instead. type=String flags=SetByConstructor
r.XeSS.FrameDump.Start=0                                                                                      ;    DEPRECATED, please use XeSS Inspector tool instead. type=Int32 flags=SetByConstructor
r.XeSS.LogLevel=1                                                                                             ;    [default: 1] Minimum log level of XeSS SDK, set it via command line -XeSSLogLevel= 0: debug, 1: info, 2: warning, 3: error, 4: off. type=Int32 flags=SetByConstructor
r.XeSS.Quality=2                                                                                              ;    [default: 2] Set XeSS quality setting. 0: Ultra Performance 1: Performance 2: Balanced 3: Quality 4: Ultra Quality 5: Ultra Quality Plus 6: Anti-Aliasing type=Int32 flags=RenderThreadSafe
r.XeSS.Supported=true                                                                                         ;    If XeSS is supported. type=Boolean flags=SetByScalability|SetBySystemSettingsIni|SetByDeviceProfile|SetByCommandLine|SetByCode
r.XeSS.Version=XeSS version: 2.0.2                                                                            ;    Show XeSS SDK's version. type=String flags=SetByScalability|SetBySystemSettingsIni|SetByDeviceProfile|SetByCommandLine|SetByCode
