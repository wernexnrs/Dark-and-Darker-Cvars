; Generated from CVars_latest_.json at 2025-12-21 18:35:42
; Entries: 358

D3D12.AdjustTexturePoolSizeBasedOnBudget=0                                                                    ;    Indicates if the RHI should lower the texture pool size when the application is over the memory budget provided by the OS. This can result in lower quality textures (but hopefully improve performance). type=Int32 flags=SetByConstructor
D3D12.Bindless.GarbageCollectLatency=600                                                                      ;    Amount of update cycles before heap is freed type=Int32 flags=SetByConstructor
D3D12.Bindless.ResourceDescriptorHeapSize=32768                                                               ;    Bindless resource descriptor heap size type=Int32 flags=SetBySystemSettingsIni
D3D12.Bindless.SamplerDescriptorHeapSize=2048                                                                 ;    Bindless sampler descriptor heap size type=Int32 flags=SetBySystemSettingsIni
D3D12.BindlessOnlineDescriptorHeapBlockSize=2000                                                              ;    Block size for sub allocations on the global view descriptor heap. type=Int32 flags=SetByConstructor
D3D12.BindlessOnlineDescriptorHeapSize=500000                                                                 ;    Online descriptor heap size type=Int32 flags=SetByConstructor
D3D12.EmitRgpFrameMarkers=0                                                                                   ;    Enables/Disables frame markers for AMD's RGP tool. type=Int32 flags=RenderThreadSafe
D3D12.EvictAllResidentResourcesInBackground=false                                                             ;    Force D3D12 resource residency manager to evict all tracked unused resources when the application is not focused\n type=Boolean flags=SetByConstructor
D3D12.GlobalResourceDescriptorHeapSize=1000000                                                                ;    Global resource descriptor heap size type=Int32 flags=SetByConstructor
D3D12.GlobalSamplerDescriptorHeapSize=2048                                                                    ;    Global sampler descriptor heap size type=Int32 flags=SetByConstructor
D3D12.GlobalSamplerHeapSize=2048                                                                              ;    Global sampler descriptor heap size type=Int32 flags=SetByConstructor
D3D12.InsertOuterOcclusionQuery=0                                                                             ;    If true, enable a dummy outer occlusion query around occlusion query batches. Can help performance on some GPU architectures type=Int32 flags=SetByConstructor
D3D12.LocalViewHeapSize=500000                                                                                ;    Local view heap size type=Int32 flags=SetByConstructor
D3D12.MaxCommandsPerCommandList=10000                                                                         ;    Flush command list to GPU after certain amount of enqueued commands (draw, dispatch, copy, ...) (default value 10000) type=Int32 flags=RenderThreadSafe
D3D12.OnlineDescriptorHeapBlockSize=2000                                                                      ;    Block size for sub allocations on the global view descriptor heap. type=Int32 flags=SetByConstructor
D3D12.OnlineDescriptorHeapSize=500000                                                                         ;    Online descriptor heap size type=Int32 flags=SetByConstructor
D3D12.PSO.DiskCache=0                                                                                         ;    Enables a disk cache for Pipeline State Objects (PSOs).\nPSO descs are cached to disk so subsequent runs can create PSOs at load-time instead of at run-time.\nThis cache contains data that is independent of hardware, driver, or machine that it was created on. It can be distributed with shipping content.\n0 to disable the pipeline state disk cache\n1 to enable the pipeline state disk cache (default)\n type=Int32 flags=SetByConstructor
D3D12.PSO.DriverOptimizedDiskCache=0                                                                          ;    Enables a disk cache for driver-optimized Pipeline State Objects (PSOs).\nPSO descs are cached to disk so subsequent runs can create PSOs at load-time instead of at run-time.\nThis cache contains data specific to the hardware, driver, and machine that it was created on.\n0 to disable the driver-optimized pipeline state disk cache\n1 to enable the driver-optimized pipeline state disk cache\n type=Int32 flags=SetByConstructor
D3D12.PSO.StallWarningThresholdInMs=100.0                                                                     ;    Sets a threshold of when to logs messages about stalls due to PSO creation.\nValue is in milliseconds. (100 is the default)\n type=Float flags=SetByConstructor
D3D12.PSOPrecache.KeepLowLevel=0                                                                              ;    Keep in memory the d3d12 PSO blob for precached PSOs. Consumes more memory but reduces stalls.\n type=Int32 flags=SetByConstructor
D3D12.ResidencyManagement=1                                                                                   ;    Controls whether D3D12 resource residency management is active (default = on). type=Int32 flags=SetByConstructor
D3D12.SamplerWarningThreshold=10                                                                              ;    Threshold to start warning about creating too many sampler states type=Int32 flags=SetByConstructor
D3D12.StablePowerState=0                                                                                      ;    Enable stable power state. This increases GPU timing measurement accuracy but may decrease overall GPU clock rate.\n    0 (default): off\n    1          : set during profiling\n    2          : set on startup\n type=Int32 flags=SetByConstructor
D3D12.TexturePoolOnlyAccountStreamableTexture=false                                                           ;    Texture streaming pool size only account streamable texture .\n - 0: All texture types are counted in the pool (legacy, default).\n - 1: Only streamable textures are counted in the pool.\nWhen enabling the new behaviour, r.Streaming.PoolSize will need to be re-adjusted.\n type=Boolean flags=SetByConstructor
D3D12.TrackAllAllocations=0                                                                                   ;    Controls whether D3D12 RHI should track all allocation information (default = off). type=Int32 flags=SetByConstructor
D3D12.UnsafeCrossGPUTransfers=true                                                                            ;    Disables cross GPU synchronization correctness, for a gain in performance (Default: true). type=Boolean flags=RenderThreadSafe
D3D12.UseUpdateTexture3DComputeShader=0                                                                       ;    If enabled, use a compute shader for UpdateTexture3D. Avoids alignment restrictions 0: off (default)\n 1: on type=Int32 flags=RenderThreadSafe
D3D12.ZeroBufferSizeInMB=4                                                                                    ;    The D3D12 RHI needs a static allocation of zeroes to use when streaming textures asynchronously. It should be large enough to support the largest mipmap you need to stream. The default is 4MB. type=Int32 flags=SetByConstructor
Demo.ExceededBudgetWarningInterval=60.0                                                                       ;    When > 0, we will wait this many seconds between logging warnings for demo recording exceeding time budgets. type=Float flags=SetByConstructor
Net.RepGraph.FixedBudget=0.0                                                                                  ;    Set fixed (independent of frame rate) packet budget. In BIts/frame type=Float flags=SetByConstructor
Net.RepGraph.UseLegacyBudget=1                                                                                ;    Use legacy IsNetReady() to make dynamic packget budgets type=Int32 flags=SetByConstructor
RHI.FeatureSetLimit=-1                                                                                        ;    If set to 10, limit D3D RHI to D3D10 feature level. Otherwise, it will use default. Changing this at run-time has no effect. (default is -1) type=Int32 flags=SetByConstructor
RHI.GPUHitchThreshold=100.0                                                                                   ;    Threshold for detecting hitches on the GPU (in milliseconds). type=Float flags=SetByConstructor
RHI.MaxSyncCounter=8                                                                                          ;    Maximum sync counter to smooth out vsync transitions. type=Int32 flags=RenderThreadSafe
RHI.MaximumFrameLatency=3                                                                                     ;    Number of frames that can be queued for render. type=Int32 flags=RenderThreadSafe
RHI.RefreshPercentageBeforePresent=1.0                                                                        ;    The percentage of the refresh period to wait before presenting. type=Float flags=RenderThreadSafe
RHI.SyncRefreshThreshold=1.0499999523162842                                                                   ;    Threshold for time above which vsync will be disabled as a percentage of the refresh rate. type=Float flags=RenderThreadSafe
RHI.SyncThreshold=7                                                                                           ;    Number of consecutive 'fast' frames before vsync is enabled. type=Int32 flags=RenderThreadSafe
RHI.SyncWithDWM=0                                                                                             ;    If true, synchronize with the desktop window manager for vblank. type=Int32 flags=RenderThreadSafe
RHI.TargetRefreshRate=0                                                                                       ;    If non-zero, the display will never update more often than the target refresh rate (in Hz). type=Int32 flags=RenderThreadSafe
RHI.TransientAllocator.BufferCacheSize=64                                                                     ;    The maximum number of RHI buffers to cache on each heap before garbage collecting. type=Int32 flags=SetByConstructor
RHI.TransientAllocator.GarbageCollectLatency=16                                                               ;    Amount of update cycles before memory is reclaimed. type=Int32 flags=SetByConstructor
RHI.TransientAllocator.MinimumHeapSize=128                                                                    ;    Minimum size of an RHI transient heap in MB. Heaps will default to this size and grow to the maximum based on the first allocation (Default 128). type=Int32 flags=SetByConstructor
RHI.TransientAllocator.ParallelResourceCreation=true                                                          ;    If enabled, a task is launched for each placed resource that is created. type=Boolean flags=RenderThreadSafe
RHI.TransientAllocator.SeparateAsyncComputeHeap=false                                                         ;    If enabled, async compute only allocations are put in their own separate heap. type=Boolean flags=RenderThreadSafe
RHI.TransientAllocator.TextureCacheSize=64                                                                    ;    The maximum number of RHI textures to cache on each heap before garbage collecting. type=Int32 flags=SetByConstructor
Sequencer.ApplyDisplayRateToDynamicResolutionFrameTimeBudget=0                                                ;    (Whether to override r.DynamicRes.FrameTimeBudget based on sequence display rate when using 'Lock to Display Rate at Runtime'. type=Int32 flags=SetByConstructor
UMG.AnimationBudgetMs=0.0                                                                                     ;    (Default: 0.0) EXPERIMENTAL: A per-frame animation budget to use for evaluation of all UMG animations this frame. type=Float flags=SetByConstructor
au.streamcaching.TrimCacheWhenOverBudget=1                                                                    ;    When set to a nonzero value, TrimMemory will be called in AddOrTouchChunk to ensure we never go over budget.\n type=Int32 flags=SetByConstructor
d3d11.ZeroBufferSizeInMB=4                                                                                    ;    The D3D11 RHI needs a static allocation of zeroes to use when streaming textures asynchronously. It should be large enough to support the largest mipmap you need to stream. The default is 4MB. type=Int32 flags=SetByConstructor
d3d12.AllowDiscardResources=1                                                                                 ;    Whether to call DiscardResources after transient aliasing acquire. This is not needed on some platforms if newly acquired resources are cleared before use. type=Int32 flags=RenderThreadSafe
d3d12.AllowPoolAllocateIndirectArgBuffers=1                                                                   ;    Allow indirect args to be pool allocated (otherwise they will be committed resources) (default: 0) type=Int32 flags=SetByConstructor
d3d12.BatchResourceBarriers=1                                                                                 ;    Whether to allow batching resource barriers type=Int32 flags=SetByConstructor
d3d12.BindResourceLabels=1                                                                                    ;    Whether to enable binding of debug names to D3D12 resources. type=Int32 flags=SetByConstructor
d3d12.ExtraDepthTransitions=0                                                                                 ;    Adds extra transitions for the depth buffer to fix validation issues. However, this currently breaks async compute type=Int32 flags=SetByConstructor
d3d12.FastAllocator.MinPagesToRetain=5                                                                        ;    Minimum number of pages to retain. Pages below this limit will never be released. Pages above can be released after being unused for a certain number of frames. type=Int32 flags=SetByConstructor
d3d12.FastConstantAllocatorPageSize=65536                                                                     ;    Page size for the fast constant allocator type=Int32 flags=SetByConstructor
d3d12.PoolAllocator.RTUAVTextureMaxAllocationSize=0                                                           ;    Maximum size of a single allocation in the VRAM RTUAV Texture pool allocator (default 0MB - disabled) type=Int32 flags=SetByConstructor
d3d12.PoolAllocator.RTUAVTextureVRAMPoolSize=0                                                                ;    Pool size of a single VRAM RTUAV Texture memory pool (default 0MB - disabled) type=Int32 flags=SetByConstructor
d3d12.PoolAllocator.ReadOnlyTextureMaxAllocationSize=67108864                                                 ;    Maximum size of a single allocation in the VRAM ReadOnly Texture pool allocator (default 64MB) type=Int32 flags=SetByConstructor
d3d12.PoolAllocator.ReadOnlyTextureVRAMPoolSize=67108864                                                      ;    Pool size of a single VRAM ReadOnly Texture memory pool (default 64MB) type=Int32 flags=SetByConstructor
d3d12.ReadOnlyTextureAllocator.MaxPoolSize=20971520                                                           ;    Maximum allocation granularity (in bytes) of each size list type=Int32 flags=SetByConstructor
d3d12.ReadOnlyTextureAllocator.MinNumToPool=8                                                                 ;    Texture pool of each size list must be large enough to store thismany textures unless constrained by maximum allocation granularity type=Int32 flags=SetByConstructor
d3d12.ReadOnlyTextureAllocator.MinPoolSize=4194304                                                            ;    Minimum allocation granularity (in bytes) of each size list type=Int32 flags=SetByConstructor
d3d12.ReservedResourceHeapSizeMB=16                                                                           ;    Size of the backing heaps for reserved resources in megabytes (default 16MB). type=Int32 flags=SetByConstructor
d3d12.UploadHeap.BigBlock.MaxAllocationSize=67108864                                                          ;    Maximum allocation size on the big block allocator for upload memory type=Int32 flags=SetByConstructor
d3d12.UploadHeap.BigBlock.PoolSize=8388608                                                                    ;    Pool size for the upload memory big block allocator type=Int32 flags=SetByConstructor
d3d12.UploadHeap.SmallBlock.MaxAllocationSize=65536                                                           ;    Maximum allocation size on the small block allocator for upload memory type=Int32 flags=SetByConstructor
d3d12.UploadHeap.SmallBlock.PoolSize=4194304                                                                  ;    Pool size for the upload memory small block allocator type=Int32 flags=SetByConstructor
d3d12.VRAMBufferPoolDefrag=1                                                                                  ;    Defrag the VRAM buffer pool type=Int32 flags=SetByConstructor
d3d12.VRAMBufferPoolDefrag.MaxCopySizePerFrame=33554432                                                       ;    Max amount of data to copy during defragmentation in a single frame (default 32MB) type=Int32 flags=SetByConstructor
d3d12.VRAMTexturePoolDefrag=1                                                                                 ;    Defrag the VRAM Texture pool (enabled by default) type=Int32 flags=SetByConstructor
d3d12.VRAMTexturePoolDefrag.MaxCopySizePerFrame=33554432                                                      ;    Max amount of data to copy during defragmentation in a single frame (default 32MB) type=Int32 flags=SetByConstructor
fx.Budget.AdjustedUsageDecayRate=0.10000000149011612                                                          ;    Rate at which the FX budget adjusted usage value is allowed to decay. This helps prevent FX flipping off/on if the usage oscilates over the cull threshold as the FX are culled/enabled. type=Float flags=SetByConstructor
fx.Budget.AdjustedUsageMax=2.0                                                                                ;    Max value for FX Budget adjusted usage. Prevents one very long frame from keeping the usage above 1.0 for long periods under budget. type=Float flags=SetByConstructor
fx.Budget.Debug.GameThreadConcurrentTimeOverride=-1.0                                                         ;    When >= 0.0 overrides the reported time for FX on the GameThreadConcurrent. Useful for observing/debugging the impact on other systems. type=Float flags=SetByConstructor
fx.Budget.Debug.GameThreadTimeOverride=-1.0                                                                   ;    When >= 0.0 overrides the reported time for FX on the GameThread. Useful for observing/debugging the impact on other systems. type=Float flags=SetByConstructor
fx.Budget.Debug.RenderThreadTimeOverride=-1.0                                                                 ;    When >= 0.0 overrides the reported time for FX on the RenderThread. Useful for observing/debugging the impact on other systems. type=Float flags=SetByConstructor
fx.Budget.Enabled=false                                                                                       ;    Controls whether we track global FX budgets. type=Boolean flags=SetByConstructor
fx.Budget.GameThread=2.0                                                                                      ;    Budget (in ms) for all combined FX work that runs only on the gamethread. As this budget is approached or exceeded, various FX systems will attempt to scale down more and mroe agressively to remain in budget. type=Float flags=SetByConstructor
fx.Budget.GameThreadConcurrent=2.0                                                                            ;    Budget (in ms) for all combined FX work that runs on the gamethread or on a concurrent task spawned from the game thread. As this budget is approached or exceeded, various FX systems will attempt to scale down more and mroe agressively to remain in budget. type=Float flags=SetByConstructor
fx.Budget.HistoryFrames=60                                                                                    ;    Number of frames the global FX budget tracking will hold to work out it's average frame time. type=Int32 flags=SetByConstructor
fx.Budget.RenderThread=2.0                                                                                    ;    Budget (in ms) for all combined FX work that runs on the Render Thread.  As this budget is approached or exceeded, various FX systems will attempt to scale down more and mroe agressively to remain in budget. type=Float flags=SetByConstructor
fx.Niagara.Scalability.GlobalBudgetCulling=1                                                                  ;    When non-zero, high level scalability culling based on global time budget is enabled. type=Int32 flags=SetByConstructor
fx.Niagara.UseGlobalFXBudget=true                                                                             ;    If true, Niagara will track performace data into the global FX budget and feed the global budget values into scalability. \n type=Boolean flags=SetByConstructor
memory.MemoryPressureCriticalThresholdMB=512.0                                                                ;    When the available physical memory drops below this threshold memory stats will consider this to be at critical pressure.\nWhere a platform can specifically state it's memory pressure this test maybe ignored.\n0 (default) critical pressure will not use the threshold. type=Float flags=SetBySystemSettingsIni
memory.WindowsPlatformMemoryGetStatsLimitTotalGB=0                                                            ;    Set a synthetic platform total memory size (in GB) which will be returned as Total and Available memory from GetStats\n type=Int32 flags=SetByConstructor
memory.WindowsPlatformMemoryUseContainerMemory=false                                                          ;    Set to assume that this process is running in a docker container and take the entire container's memory usage into consideration when computing available memory. type=Boolean flags=SetByConstructor
memory.logGenericPlatformMemoryStats=1                                                                        ;    Report Platform Memory Stats)\n type=Int32 flags=SetByConstructor
p.aabbtree.UseTimeSliceMillisecondBudget=true                                                                 ;    Set to True if we want to timeslice tree generation by a milisecond budget instead of per nodes processed type=Boolean flags=SetByConstructor
r.AMDD3D11MultiThreadedDevice=0                                                                               ;    If true, creates a multithreaded D3D11 device on AMD hardware (workaround for driver bug)\nChanges will only take effect in new game/editor instances - can't be changed at runtime.\n type=Int32 flags=SetByConstructor
r.AmbientOcclusion.AsyncComputeBudget=1                                                                       ;    Defines which level of EAsyncComputeBudget to use for balancing AsyncCompute work against Gfx work.\nOnly matters if the compute version of SSAO is active (requires CS support, enabled by cvar, single pass, no normals)\nThis is a low level developer tweak to get best performance on hardware that supports AsyncCompute.\n 0: least AsyncCompute\n 1: .. (default)\n 2: .. \n 3: .. \n 4: most AsyncCompute type=Int32 flags=RenderThreadSafe
r.ComputeFramework.TriggerGPUCaptureDispatches=0                                                              ;    Trigger GPU captures for this many of the subsequent compute graph dispatches. type=Int32 flags=RenderThreadSafe
r.D3D.CheckedForTypedUAVs=1                                                                                   ;    Whether to disallow usage of typed UAV loads, as they are unavailable in Windows 7 D3D 11.0.\n 0: Allow usage of typed UAV loads.\n 1: Disallow usage of typed UAV loads. (default) type=Int32 flags=SetByConstructor
r.D3D.ForceDXC=0                                                                                              ;    Forces DirectX Shader Compiler (DXC) to be used for all D3D shaders. Shaders compiled with this option are only compatible with D3D12.\n 0: Disable (default)\n 1: Force new compiler for all shaders type=Int32 flags=SetByConstructor
r.D3D11.AbsoluteTimeQueryTimeoutValue=30.0                                                                    ;    Set the timeout value, in seconds, to wait for a D3D11 absolute time query. type=Float flags=SetByConstructor
r.D3D11.AutoFlushUAV=1                                                                                        ;    If enabled, use NVAPI (Nvidia), AGS (AMD) or Intel Extensions (Intel) to not flush between dispatches/draw calls 1: on (default)\n 0: off type=Int32 flags=RenderThreadSafe
r.D3D11.Depth24Bit=0                                                                                          ;    0: Use 32-bit float depth buffer\n1: Use 24-bit fixed point depth buffer(default)\n type=Int32 flags=SetByConstructor
r.D3D11.EnableD3DDebug=0                                                                                      ;    0 to disable d3ddebug layer (default)\n1 to enable error logging (-d3ddebug) \n2 to enable error & warning logging (-d3dlogwarnings)\n3 to enable breaking on errors & warnings (-d3dbreakonwarning)\n4 to enable CONTINUING on errors (-d3dcontinueonerrors)\n type=Int32 flags=RenderThreadSafe
r.D3D11.QueryTimeoutValue=5.0                                                                                 ;    Set the timeout value, in seconds, to wait for a D3D11 query. This value does not apply to absolute time queries (which are controlled by r.D3D11.AbsoluteTimeQueryTimeoutValue). type=Float flags=SetByConstructor
r.D3D11.UseAllowTearing=1                                                                                     ;    Enable new dxgi flip mode with d3d11 type=Int32 flags=RenderThreadSafe
r.D3D11.UseSharedKeyMutex=0                                                                                   ;    If 1, BUF_Shared vertex / index buffer and TexCreate_Shared texture will be created\nwith the D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX flag instead of D3D11_RESOURCE_MISC_SHARED (default).\n type=Int32 flags=SetByConstructor
r.D3D12.AllowAsyncCompute=1                                                                                   ;    Allow usage of async compute type=Int32 flags=RenderThreadSafe
r.D3D12.DRED=0                                                                                                ;    Enable DRED GPU Crash debugging mode to track the current GPU state and logs information what operations the GPU executed last.Has GPU overhead but gives the most information on the current GPU state when it crashes or hangs.\n type=Int32 flags=RenderThreadSafe
r.D3D12.DXR.MinimumDriverVersionAMD=0                                                                         ;    Sets the minimum driver version required to enable ray tracing on AMD GPUs. type=Int32 flags=RenderThreadSafe
r.D3D12.DXR.MinimumDriverVersionNVIDIA=0                                                                      ;    Sets the minimum driver version required to enable ray tracing on NVIDIA GPUs. type=Int32 flags=RenderThreadSafe
r.D3D12.DXR.MinimumWindowsBuildVersion=0                                                                      ;    Sets the minimum Windows build version required to enable ray tracing. type=Int32 flags=RenderThreadSafe
r.D3D12.Depth24Bit=0                                                                                          ;    0: Use 32-bit float depth buffer\n1: Use 24-bit fixed point depth buffer(default)\n type=Int32 flags=SetByConstructor
r.D3D12.DevDisableD3DRuntimeBackgroundThreads=0                                                               ;    If > 0, disables the background threads created by the D3D runtime for background shader optimization. Only available when Windows developer mode is enabled. (default = 0). type=Int32 flags=SetByConstructor
r.D3D12.DiagnosticBufferExtraMemory=0                                                                         ;    Extra allocated memory for diagnostic buffer type=Int32 flags=SetByConstructor
r.D3D12.EnableD3DDebug=0                                                                                      ;    0 to disable d3ddebug layer (default)\n1 to enable error logging (-d3ddebug) \n2 to enable error & warning logging (-d3dlogwarnings)\n3 to enable breaking on errors & warnings (-d3dbreakonwarning)\n4 to enable CONTINUING on errors (-d3dcontinueonerrors)\n type=Int32 flags=RenderThreadSafe
r.D3D12.ExplicitDescriptorHeap.DeduplicateSamplers=1                                                          ;    Use an exhaustive search to deduplicate sampler descriptors when generating shader binding tables. Reduces sampler heap usage at the cost of some CPU time. (default = 1) type=Int32 flags=SetByConstructor
r.D3D12.ExplicitDescriptorHeap.ViewDescriptorHeapSize=250000                                                  ;    Maximum number of descriptors per explicit view descriptor heap. (default = 250k, ~8MB per heap)\nTypical measured descriptor heap usage in large scenes is ~50k. An error is reported when this limit is reached and shader bindings for subsequent objects are skipped.\n type=Int32 flags=SetByConstructor
r.D3D12.GPUTimeFromTimestamps=0                                                                               ;    Prefer timestamps instead of GetHardwareGPUFrameTime to compute GPU frame time type=Int32 flags=RenderThreadSafe
r.D3D12.GPUTimeout=1                                                                                          ;    0: Disable GPU Timeout; use with care as it could freeze your PC!\n1: Enable GPU Timeout; operation taking long on the GPU will fail(default)\n type=Int32 flags=SetByConstructor
r.D3D12.LightweightDRED=0                                                                                     ;    Enable Lightweight DRED GPU Crash debugging mode to track the current GPU state and logs information what operations the GPU executed last.Gives the basic information on the current GPU state when it crashes or hangs on all PC hardware.\n type=Int32 flags=RenderThreadSafe
r.D3D12.RayTracing.AllowCompaction=1                                                                          ;    Whether to automatically perform compaction for static acceleration structures to save GPU memory. (default = 1)\n type=Int32 flags=SetByConstructor
r.D3D12.RayTracing.AllowSpecializedStateObjects=1                                                             ;    Whether to use specialized RTPSOs if they have been created. This is intended for performance testingand has no effect if r.D3D12.RayTracing.SpecializeStateObjects is 0. (default = 1)\n type=Int32 flags=SetByConstructor
r.D3D12.RayTracing.CacheShaderRecords=1                                                                       ;    Automatically cache and re-use SBT hit group records. This significantly improves CPU performance in large scenes with many identical mesh instances. (default = 1)\nThis mode assumes that contents of uniform buffers does not change during ray tracing resource binding. type=Int32 flags=SetByConstructor
r.D3D12.RayTracing.DebugForceBuildMode=0                                                                      ;    Forces specific acceleration structure build mode (not runtime-tweakable).\n0: Use build mode requested by high-level code (Default)\n1: Force fast build mode\n2: Force fast trace mode\n type=Int32 flags=SetByConstructor
r.D3D12.RayTracing.GPUValidation=0                                                                            ;    Whether to perform validation of ray tracing geometry and other structures on the GPU. Requires Shader Model 6. (default = 0) type=Int32 flags=SetByConstructor
r.D3D12.RayTracing.MaxBatchedCompaction=64                                                                    ;    Maximum of amount of compaction requests and rebuilds per frame. (default = 64)\n type=Int32 flags=SetByConstructor
r.D3D12.RayTracing.SpecializeStateObjects=0                                                                   ;    Whether to create specialized unique ray tracing pipeline state objects for each ray generation shader. (default = 0)\nThis option can produce more more efficient PSOs for the GPU at the cost of longer creation times and more memory. Requires DXR 1.1.\n type=Int32 flags=SetByConstructor
r.D3D12.SubmissionTimeout=5.0                                                                                 ;    The maximum time, in seconds, that a submitted GPU command list is allowed to take before the RHI reports a GPU hang type=Float flags=RenderThreadSafe
r.D3D12.UseAllowTearing=1                                                                                     ;    Enable new dxgi flip mode with d3d12 type=Int32 flags=RenderThreadSafe
r.DX11.ReduceRTVRebinds=1                                                                                     ;    Reduce # of SetRenderTargetCalls. type=Int32 flags=SetByConstructor
r.DynamicRes.FrameTimeBudget=33.29999923706055                                                                ;    Frame's time budget in milliseconds. type=Float flags=RenderThreadSafe
r.DynamicRes.MaxConsecutiveOverBudgetGPUFrameCount=2                                                          ;    Maximum number of consecutive frames tolerated over GPU budget. type=Int32 flags=RenderThreadSafe
r.DynamicRes.OverBudgetGPUHeadRoomPercentage=0.0                                                              ;    Amount of GPU headroom needed from which the frame is considered over budget. This is for platform not supporting controllable tearing with VSync (in percent from r.DynamicRes.FrameTimeBudget). type=Float flags=RenderThreadSafe
r.ExrReaderGPU.ForceTileDescBuffer=true                                                                       ;    Calculates tile description and offsets on CPU and provides a Structured buffer.\nto be used to access tile description on GPU\n type=Boolean flags=SetByConstructor
r.ExrReaderGPU.UseUploadHeap=true                                                                             ;    Utilizes upload heap and copies raw exr buffer asynchronously.\n			Requires a restart of the engine. type=Boolean flags=SetByConstructor
r.FastVRam.Bloom=1                                                                                            ;    type=Int32 flags=SetByConstructor
r.FastVRam.BokehDOF=1                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.CircleDOF=1                                                                                        ;    type=Int32 flags=SetByConstructor
r.FastVRam.CombineLUTs=1                                                                                      ;    type=Int32 flags=SetByConstructor
r.FastVRam.CustomDepth=0                                                                                      ;    type=Int32 flags=SetByConstructor
r.FastVRam.DBufferA=0                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.DBufferB=0                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.DBufferC=0                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.DBufferMask=0                                                                                      ;    type=Int32 flags=SetByConstructor
r.FastVRam.DOFPostfilter=1                                                                                    ;    type=Int32 flags=SetByConstructor
r.FastVRam.DOFReduce=1                                                                                        ;    type=Int32 flags=SetByConstructor
r.FastVRam.DOFSetup=1                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.DistanceFieldAOBentNormal=0                                                                        ;    type=Int32 flags=SetByConstructor
r.FastVRam.DistanceFieldAODownsampledBentNormal=1                                                             ;    type=Int32 flags=SetByConstructor
r.FastVRam.DistanceFieldAOHistory=1                                                                           ;    type=Int32 flags=SetByConstructor
r.FastVRam.DistanceFieldAOScreenGridResources=1                                                               ;    type=Int32 flags=SetByConstructor
r.FastVRam.DistanceFieldCulledObjectBuffers=1                                                                 ;    type=Int32 flags=SetByConstructor
r.FastVRam.DistanceFieldIrradiance=0                                                                          ;    type=Int32 flags=SetByConstructor
r.FastVRam.DistanceFieldNormal=1                                                                              ;    type=Int32 flags=SetByConstructor
r.FastVRam.DistanceFieldShadows=1                                                                             ;    type=Int32 flags=SetByConstructor
r.FastVRam.DistanceFieldTileIntersectionResources=1                                                           ;    type=Int32 flags=SetByConstructor
r.FastVRam.Distortion=1                                                                                       ;    type=Int32 flags=SetByConstructor
r.FastVRam.Downsample=1                                                                                       ;    type=Int32 flags=SetByConstructor
r.FastVRam.EyeAdaptation=1                                                                                    ;    type=Int32 flags=SetByConstructor
r.FastVRam.ForwardLightingCullingResources=1                                                                  ;    type=Int32 flags=SetByConstructor
r.FastVRam.GBufferA=0                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.GBufferB=1                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.GBufferC=0                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.GBufferD=0                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.GBufferE=0                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.GBufferF=0                                                                                         ;    type=Int32 flags=SetByConstructor
r.FastVRam.GBufferVelocity=0                                                                                  ;    type=Int32 flags=SetByConstructor
r.FastVRam.GlobalDistanceFieldCullGridBuffers=1                                                               ;    type=Int32 flags=SetByConstructor
r.FastVRam.HZB=1                                                                                              ;    type=Int32 flags=SetByConstructor
r.FastVRam.Histogram=1                                                                                        ;    type=Int32 flags=SetByConstructor
r.FastVRam.HistogramReduce=1                                                                                  ;    type=Int32 flags=SetByConstructor
r.FastVRam.MotionBlur=1                                                                                       ;    type=Int32 flags=SetByConstructor
r.FastVRam.PostProcessMaterial=1                                                                              ;    type=Int32 flags=SetByConstructor
r.FastVRam.SSR=0                                                                                              ;    type=Int32 flags=SetByConstructor
r.FastVRam.SceneColor=1                                                                                       ;    type=Int32 flags=SetByConstructor
r.FastVRam.SceneDepth=1                                                                                       ;    type=Int32 flags=SetByConstructor
r.FastVRam.ScreenSpaceAO=0                                                                                    ;    type=Int32 flags=SetByConstructor
r.FastVRam.ScreenSpaceShadowMask=1                                                                            ;    type=Int32 flags=SetByConstructor
r.FastVRam.SeparateTranslucency=0                                                                             ;    type=Int32 flags=SetByConstructor
r.FastVRam.SeparateTranslucencyModulate=0                                                                     ;    type=Int32 flags=SetByConstructor
r.FastVRam.ShadowCSM=0                                                                                        ;    type=Int32 flags=SetByConstructor
r.FastVRam.ShadowPerObject=0                                                                                  ;    type=Int32 flags=SetByConstructor
r.FastVRam.ShadowPointLight=0                                                                                 ;    type=Int32 flags=SetByConstructor
r.FastVRam.Tonemap=1                                                                                          ;    type=Int32 flags=SetByConstructor
r.FastVRam.Upscale=1                                                                                          ;    type=Int32 flags=SetByConstructor
r.FastVRam.VelocityFlat=1                                                                                     ;    type=Int32 flags=SetByConstructor
r.FastVRam.VelocityMax=1                                                                                      ;    type=Int32 flags=SetByConstructor
r.FastVRam.VolumetricFog=1                                                                                    ;    type=Int32 flags=SetByConstructor
r.GPUCrashDebugging=0                                                                                         ;    Enable vendor specific GPU crash analysis tools type=Int32 flags=SetByScalability|SetByGameSetting|SetByProjectSetting
r.GPUCrashDebugging.Aftermath=1                                                                               ;    Enables or disables Nvidia Aftermath. type=Int32 flags=SetByConstructor
r.GPUCrashDebugging.Aftermath.Callstack=0                                                                     ;    Enable callstack capture in Aftermath dumps type=Int32 flags=SetByConstructor
r.GPUCrashDebugging.Aftermath.DumpShaderDebugInfo=0.0                                                         ;    Dump shader debug info (.nvdbg) alongside the crash dump. type=Float flags=SetByConstructor
r.GPUCrashDebugging.Aftermath.DumpWaitTime=10.0                                                               ;    Amount of time (in seconds) to wait for Aftermath to finish processing GPU crash dumps. type=Float flags=SetByConstructor
r.GPUCrashDebugging.Aftermath.Markers=0                                                                       ;    Enable draw event markers in Aftermath dumps type=Int32 flags=SetByConstructor
r.GPUCrashDebugging.Aftermath.ResourceTracking=1                                                              ;    Enable resource tracking for Aftermath dumps type=Int32 flags=SetByConstructor
r.GPUCrashDebugging.Aftermath.TrackAll=0                                                                      ;    Enable maximum tracking for Aftermath dumps type=Int32 flags=SetByConstructor
r.GPUCrashDebugging.Breadcrumbs=1                                                                             ;    Enable RHI breadcrumbs, a vendor-agnostic method for determining which passes were active when a GPU crash occurs type=Int32 flags=SetByConstructor
r.GPUCrashOnOutOfMemory=0                                                                                     ;    Enable crash reporting on GPU OOM type=Int32 flags=SetByConstructor
r.Lumen.IrradianceFieldGather.NumProbesToTraceBudget=200                                                      ;    Number of probes that can be updated in a frame before downsampling. type=Int32 flags=RenderThreadSafe
r.Lumen.ScreenProbeGather.RadianceCache.NumProbesToTraceBudget=300                                            ;    type=Int32 flags=RenderThreadSafe|Scalability|SetByScalability
r.Lumen.TranslucencyVolume.RadianceCache.NumProbesToTraceBudget=200                                           ;    type=Int32 flags=RenderThreadSafe|Scalability|SetByScalability
r.NVIDIATimestampWorkaround=1                                                                                 ;    If true we disable timestamps on pre-maxwell hardware (workaround for driver bug)\n type=Int32 flags=SetByConstructor
r.Nanite.PrimaryRaster.TimeBudgetMs=0.0                                                                       ;    Frame's time budget for Nanite primary raster in milliseconds. type=Float flags=RenderThreadSafe
r.Nanite.ShadowRaster.TimeBudgetMs=0.0                                                                        ;    Frame's time budget for Nanite shadow raster in milliseconds. type=Float flags=RenderThreadSafe
r.PSOPrecache.D3D12.DriverCacheAware=0                                                                        ;    If enabled, the PSO precaching system will not precache PSOs that the D3D12 graphics driver considers similar for caching, i.e. it will not precache PSOs that while technically different will still result in a driver cache hit.\nThis is not implemented for all GPU vendors and can result in performance issues or cache misses if the heuristics the engine uses does not match the graphics driver's behavior that decides whether a PSO is in the cache or not. type=Int32 flags=SetByConstructor
r.ProfileGPU.AssetSummaryCallOuts=                                                                            ;    Comma separated list of substrings that deserve special mention in the final summary (e.g., "LOD,HeroName"\nr.ProfileGPU.PrintAssetSummary must be true to enable this feature type=String flags=SetByConstructor
r.ProfileGPU.Pattern=*                                                                                        ;    Allows to filter the entries when using ProfileGPU, the pattern match is case sensitive.\n'*' can be used in the end to get all entries starting with the string.\n    '*' without any leading characters disables the pattern matching and uses a time threshold instead (default).\n'?' allows to ignore one character.\ne.g. AmbientOcclusionSetup, AmbientOcclusion*, Ambient???lusion*, * type=String flags=SetByConstructor
r.ProfileGPU.PrintAssetSummary=0                                                                              ;    Should we print a summary split by asset (r.ShowMaterialDrawEvents is strongly recommended as well).\n type=Int32 flags=SetByConstructor
r.ProfileGPU.Root=*                                                                                           ;    Allows to filter the tree when using ProfileGPU, the pattern match is case sensitive. type=String flags=SetByConstructor
r.ProfileGPU.Screenshot=1                                                                                     ;    Whether a screenshot should be taken when profiling the GPU. 0:off, 1:on (default) type=Int32 flags=RenderThreadSafe
r.ProfileGPU.ShowEventHistogram=0                                                                             ;    Whether the event histogram should be shown. type=Int32 flags=SetByConstructor
r.ProfileGPU.ShowLeafEvents=1                                                                                 ;    Allows profileGPU to display event-only leaf nodes with no draws associated. type=Int32 flags=SetByConstructor
r.ProfileGPU.ShowTransitions=0                                                                                ;    Allows profileGPU to display resource transition events. type=Int32 flags=SetByConstructor
r.ProfileGPU.ShowUI=1                                                                                         ;    Whether the user interface profiler should be displayed after profiling the GPU.\nThe results will always go to the log/console\n0:off, 1:on (default) type=Int32 flags=RenderThreadSafe
r.ProfileGPU.Sort=0                                                                                           ;    Sorts the TTY Dump independently at each level of the tree in various modes.\n0 : Chronological\n1 : By time elapsed\n2 : By number of prims\n3 : By number of verts\n type=Int32 flags=SetByConstructor
r.ProfileGPU.ThresholdPercent=0.0                                                                             ;    Percent of the total execution duration the event needs to be larger than to be printed. type=Float flags=SetByConstructor
r.RHICmd.ParallelTranslate.CombineSingleAndParallel=false                                                     ;    When true, allows the batching of both parallel and single threaded RHI command lists into the same translate job. Any parallel command lists that get batched with a single thread command list will fall back to translating on the RHI thread. Enabling this may trade reduced parallelism for reduced dispatch overhead. type=Boolean flags=SetByConstructor
r.RHICmd.ParallelTranslate.Enable=true                                                                        ;    When true, allows recorded RHI command lists to be translated in parallel, on supported platforms. Setting this to false will make all command lists translate on the RHI thread. type=Boolean flags=SetByConstructor
r.RHICmd.ParallelTranslate.MaxCommandsPerTranslate=256                                                        ;    When parallel translation is enabled, specifies the target maximum number of RHI command list commands to allow in a single translation job. If a newly submitted command list would cause an existing translate job to exceed this threshold, a new job will be started. A value of 0 means 'no limit'. Translate jobs will not be split. A value less than 0 means 'always split'. Command lists will never be batched together in the same translate job. type=Int32 flags=SetByConstructor
r.RHICmdBufferWriteLocks=1                                                                                    ;    Only relevant with an RHI thread. Debugging option to diagnose problems with buffered locks. type=Int32 flags=SetByConstructor
r.RHICmdBypass=0                                                                                              ;    Whether to bypass the rhi command list and send the rhi commands immediately.\n0: Disable (required for the multithreaded renderer)\n1: Enable (convenient for debugging low level graphics API calls, can suppress artifacts from multithreaded renderer code) type=Int32 flags=SetByConstructor
r.RHICmdMaxOutstandingMemoryBeforeFlush=256                                                                   ;    In kilobytes. The amount of outstanding memory before the RHI will force a flush. This should generally be set high enough that it doesn't happen on typical frames. type=Int32 flags=SetByConstructor
r.RHICmdMinDrawsPerParallelCmdList=64                                                                         ;    The minimum number of draws per cmdlist. If the total number of draws is less than this, then no parallel work will be done at all. This can't always be honored or done correctly. type=Int32 flags=SetByConstructor
r.RHICmdWidth=8                                                                                               ;    Controls the task granularity of a great number of things in the parallel renderer. type=Int32 flags=SetByConstructor
r.RHIRenderPasses=0                                                                                           ;    type=Int32 flags=SetByConstructor
r.RayTracing.UseReferenceBasedResidency=false                                                                 ;    (EXPERIMENTAL) Whether raytracing geometries should be resident or evicted based on whether they're referenced in TLAS type=Boolean flags=RenderThreadSafe
r.Streaming.LimitPoolSizeToVRAM=1                                                                             ;    If non-zero, texture pool size with be limited to how much GPU mem is available. type=Int32 flags=Scalability|SetByScalability
r.Streaming.PoolSize.VRAMPercentageClamp=1024                                                                 ;    When using PoolSizeVRAMPercentage, a maximum amout of memory to reserve in MB.\nThis avoids reserving too much space for systems with a lot of VRAM. (default=1024) type=Int32 flags=SetByConstructor
r.Translucency.DynamicRes.TimeBudget=0.0                                                                      ;    Frame's time budget for translucency rendering in milliseconds. type=Float flags=RenderThreadSafe
r.VT.AVT.MaxPageResidency=75                                                                                  ;    Percentage of page table to allocate before we start freeing to make space type=Int32 flags=RenderThreadSafe
r.VT.Residency.AdjustmentRate=0.20000000298023224                                                             ;    Rate at which we adjust mip bias due to Virtual Texture pool residency.\nDefault 0.2 type=Float flags=RenderThreadSafe
r.VT.Residency.LockedUpperBound=0.6499999761581421                                                            ;    Virtual Texture pool locked page residency above which we kill any mip bias.\nThat's because locked pages are never affected by the mip bias setting. So it is unlikely that we can get the pool within budget.\nDefault 0.65 type=Float flags=RenderThreadSafe
r.VT.Residency.LowerBound=0.949999988079071                                                                   ;    Virtual Texture pool residency below which we decrease mip bias.\nDefault 0.95 type=Float flags=RenderThreadSafe
r.VT.Residency.MaxMipMapBias=4.0                                                                              ;    Maximum mip bias to apply to prevent Virtual Texture pool residency over-subscription.\nDefault 4 type=Float flags=RenderThreadSafe
r.VT.Residency.Notify=0                                                                                       ;    Show on screen notifications for virtual texture physical pool residency type=Int32 flags=SetByConstructor
r.VT.Residency.Show=0                                                                                         ;    Show on screen HUD for virtual texture physical pool residency type=Int32 flags=SetByConstructor
r.VT.Residency.UpperBound=0.949999988079071                                                                   ;    Virtual Texture pool residency above which we increase mip bias.\nDefault 0.95 type=Float flags=RenderThreadSafe
r.Vulkan.AMDCompatibilityMode=1                                                                               ;    Used to tweak enabled Vulkan feature set in order to ensure wider compatibility with all AMD GPUs on all platforms. (default:1) type=Int32 flags=SetByConstructor
r.Vulkan.Allow16bitOps=0                                                                                      ;    Whether to enable 16bit ops to speeds up TSR\n0 to disable (default)\n1 to enable type=Int32 flags=SetByConstructor
r.Vulkan.Allow64bitShaderAtomics=1                                                                            ;    Whether to enable 64bit buffer/image atomics required by Nanite\n0 to disable 64bit atomics\n1 to enable (default) type=Int32 flags=SetByConstructor
r.Vulkan.AllowAsyncCompute=0                                                                                  ;    0 to disable async compute queue(if available)1 to allow async compute queue type=Int32 flags=SetByConstructor
r.Vulkan.AllowHostQueryReset=1                                                                                ;    0: Do not enable support for Host Query Reset extension\n1: Enable Host Query Reset (default) type=Int32 flags=SetByConstructor
r.Vulkan.AllowPSOPrecaching=true                                                                              ;    true: if r.PSOPrecaching=1 Vulkan RHI will use precaching. (default)\nfalse: Vulkan RHI will disable precaching (even if r.PSOPrecaching=1). type=Boolean flags=RenderThreadSafe
r.Vulkan.AllowPresentOnComputeQueue=0                                                                         ;    0 to present on the graphics queue1 to allow presenting on the compute queue if available type=Int32 flags=SetByConstructor
r.Vulkan.AllowSynchronization2=1                                                                              ;    Enables the use of advanced barriers that combine the use of the VK_KHR_separate_depth_stencil_layouts \nand VK_KHR_synchronization2 to reduce the reliance on layout tracking (except for defragging).\nThis is necessary in order to support parallel command buffer generation.\n0: Do not enable support for sync2 barriers.\n1: Enable sync2 barriers (default) type=Int32 flags=SetByConstructor
r.Vulkan.AllowUniformUpload=1                                                                                 ;    Allow Uniform Buffer uploads outside of renderpasses\n 0: Disabled, buffers are always reallocated\n 1: Enabled, buffers are uploaded outside renderpasses type=Int32 flags=SetByConstructor
r.Vulkan.AutoCorrectExpectedLayouts=1                                                                         ;    Will use layout tracking to correct mismatched layouts when setting expected layouts.  \nThis is unsafe for multi-threaded command buffer generations\n 0: Do not correct layouts.\n 1: Correct the layouts using layout tracking. (default) type=Int32 flags=SetByConstructor
r.Vulkan.AutoCorrectUnknownLayouts=1                                                                          ;    Will use layout tracking to correct unknown layouts.  \nThis is unsafe for multi-threaded command buffer generations\n 0: Do not correct layouts.\n 1: Correct the layouts using layout tracking. (default) type=Int32 flags=SetByConstructor
r.Vulkan.Bindless.BlockSize=1048576                                                                           ;    Block size to use for single use ub. (default: 1MB) type=Int32 flags=RenderThreadSafe
r.Vulkan.Bindless.MaxResourceAccelerationStructureCount=65536                                                 ;    Maximum bindless Acceleration Structure descriptor count type=Int32 flags=SetByConstructor
r.Vulkan.Bindless.MaxResourceSampledImageCount=262144                                                         ;    Maximum bindless Sampled Image descriptor count type=Int32 flags=SetByConstructor
r.Vulkan.Bindless.MaxResourceStorageBufferCount=65536                                                         ;    Maximum bindless Storage Buffer descriptor count type=Int32 flags=SetByConstructor
r.Vulkan.Bindless.MaxResourceStorageImageCount=65536                                                          ;    Maximum bindless Storage Image descriptor count type=Int32 flags=SetByConstructor
r.Vulkan.Bindless.MaxResourceStorageTexelBufferCount=65536                                                    ;    Maximum bindless Storage Texel Buffer descriptor count type=Int32 flags=SetByConstructor
r.Vulkan.Bindless.MaxResourceUniformBufferCount=32768                                                         ;    Maximum bindless Uniform Buffer descriptor count type=Int32 flags=SetByConstructor
r.Vulkan.Bindless.MaxResourceUniformTexelBufferCount=65536                                                    ;    Maximum bindless Uniform Texel Buffer descriptor count type=Int32 flags=SetByConstructor
r.Vulkan.Bindless.MaxSamplerDescriptorCount=2048                                                              ;    Maximum bindless sampler descriptor count type=Int32 flags=SetByConstructor
r.Vulkan.BudgetScale=100                                                                                      ;    Percentage Scaling of MemoryBudget. Valid range is [0-100]. Only has an effect if VK_EXT_memory_budget is available type=Int32 flags=RenderThreadSafe
r.Vulkan.CPURHIThreadFramePacer=1                                                                             ;    Whether to enable the simple RHI thread CPU Framepacer for Vulkan type=Int32 flags=RenderThreadSafe
r.Vulkan.CPURenderthreadFramePacer=1                                                                          ;    Whether to enable the simple Render thread CPU Framepacer for Vulkan type=Int32 flags=RenderThreadSafe
r.Vulkan.ChunkedPSOCache.ChunkEvictTime=60                                                                    ;    Time in seconds for a cache chunk to be unused before it can be evicted from ram.\n(default) 60 type=Int32 flags=RenderThreadSafe
r.Vulkan.ChunkedPSOCache.MaxSingleCachePSOCount=20                                                            ;    The target PSO count for an individual PSO cache.\nexisting caches with different PSO counts are discarded at startup.\n(default) 20 type=Int32 flags=RenderThreadSafe
r.Vulkan.ChunkedPSOCache.MaxTotalCacheSizeMb=300                                                              ;    At startup, if the entire cache is above this threshold the cache will be deleted\nand rebuilt during the subsequent run.\n(default) 300\n0 to disable cache size limit, note that the cache will grow indefinitely. type=Int32 flags=RenderThreadSafe
r.Vulkan.ChunkedPSOCache.TargetResidentCacheSizeMb=40                                                         ;    A target resident cache size in MB, if the combined memory usage of all the currently loaded cache chunks is above this threshold\nthe least recently used chunks will be considered for eviction.\n(default) 40 type=Int32 flags=RenderThreadSafe
r.Vulkan.CompressSPIRV=0                                                                                      ;    0 SPIRV source is stored in RAM as-is. (default)\n1 SPIRV source is compressed on load and decompressed as when needed, this saves RAM but can introduce hitching when creating shaders. type=Int32 flags=RenderThreadSafe
r.Vulkan.CpuWaitForFence=1                                                                                    ;    Whether to have the Cpu wait for the fence in AcquireImageIndex type=Int32 flags=RenderThreadSafe
r.Vulkan.DSetCacheMaxPoolLookups=2                                                                            ;    Maximum count of pool's caches to lookup before allocating new descriptor.\n type=Int32 flags=RenderThreadSafe
r.Vulkan.DSetCacheTargetSetsPerPool=4096                                                                      ;    Target number of descriptor set allocations per single pool.\n type=Int32 flags=RenderThreadSafe
r.Vulkan.DefragAgeDelay=100                                                                                   ;    Delay in Frames that needs to pass before attempting to defrag a page again\n type=Int32 flags=RenderThreadSafe
r.Vulkan.DefragAutoPause=0                                                                                    ;    Automatically Pause defragging after a single page has been defragged. Only for debugging the defragmentation code. type=Int32 flags=RenderThreadSafe
r.Vulkan.DefragOnceDebug=0                                                                                    ;    Set to 1 to test defrag type=Int32 flags=RenderThreadSafe
r.Vulkan.DefragPaused=0                                                                                       ;    Pause Any defragging. Only for debugging defragmentation code type=Int32 flags=RenderThreadSafe
r.Vulkan.DefragSizeFactor=1.2999999523162842                                                                  ;    Amount of space required to be free, on other pages, before attempting to do a defrag of a page type=Float flags=RenderThreadSafe
r.Vulkan.DefragSizeFraction=0.699999988079071                                                                 ;    Fill threshold, dont attempt defrag if free space is less than this fraction\n type=Float flags=RenderThreadSafe
r.Vulkan.DelayAcquireBackBuffer=1                                                                             ;    Whether to delay acquiring the back buffer \n 0: acquire next image on frame start \n 1: acquire next image just before presenting, rendering is done to intermediate image which is then copied to a real backbuffer (default) \n 2: acquire next image on first use type=Int32 flags=SetByConstructor
r.Vulkan.Depth24Bit=0                                                                                         ;    0: Use 32-bit float depth buffer (default)\n1: Use 24-bit fixed point depth buffer\n type=Int32 flags=SetByConstructor
r.Vulkan.DepthStencilForceStorageBit=0                                                                        ;    Whether to force Image Usage Storage on Depth (can disable framebuffer compression).\n 0: Not enabled\n 1: Enables override for IMAGE_USAGE_STORAGE type=Int32 flags=SetByConstructor
r.Vulkan.DynamicGlobalUBs=2                                                                                   ;    2 to treat ALL uniform buffers as dynamic [default]\n1 to treat global/packed uniform buffers as dynamic\n0 to treat them as regular type=Int32 flags=RenderThreadSafe
r.Vulkan.EnableDedicatedImageMemory=1                                                                         ;    Enable to use Dedidcated Image memory on devices that prefer it. type=Int32 flags=RenderThreadSafe
r.Vulkan.EnableDefrag=1                                                                                       ;    Whether to enable defrag moves & evictions\n0: Off\n1: On\n type=Int32 flags=RenderThreadSafe
r.Vulkan.EnablePSOFileCacheWhenPrecachingActive=false                                                         ;    false: If precaching is available (r.PSOPrecaching=1, r.Vulkan.UseChunkedPSOCache=1) then disable the PSO filecache. (default)\ntrue: Allow both PSO file cache and precaching. type=Boolean flags=RenderThreadSafe
r.Vulkan.EnablePipelineLRUCache=0                                                                             ;    Pipeline LRU cache.\n0: disable LRU\n1: Enable LRU type=Int32 flags=RenderThreadSafe
r.Vulkan.EnableTransientResourceAllocator=1                                                                   ;    Whether to enable the TransientResourceAllocator to reduce memory usage\n0 to disabled (default)\n1 to enable\n type=Int32 flags=SetByConstructor
r.Vulkan.EvictOnePageDebug=0                                                                                  ;    Set to 1 to test evict one page to host type=Int32 flags=RenderThreadSafe
r.Vulkan.EvictionLimitPercentage=70.0                                                                         ;    When more than x% of local memory is used, evict resources to host memory type=Float flags=RenderThreadSafe
r.Vulkan.EvictionLimitPercentageRenableLimit=60.0                                                             ;    After eviction has occurred, only start using local mem for textures after memory usage is less than this(Relative to Eviction percentage) type=Float flags=RenderThreadSafe
r.Vulkan.FlushOnMapStaging=0                                                                                  ;    Flush GPU on MapStagingSurface calls without any fence.\n 0: Do not Flush (default)\n 1: Flush type=Int32 flags=SetByConstructor
r.Vulkan.ForcePSOSingleThreaded=0                                                                             ;    Enable to force singlethreaded creation of PSOs. Only intended as a workaround for buggy drivers\n0: (default) Allow Async precompile PSO creation.\n1: force singlethreaded creation of all PSOs.\n2: force singlethreaded creation of precompile PSOs only.\n3: force singlethreaded creation of non-precompile PSOs only. type=Int32 flags=RenderThreadSafe
r.Vulkan.ForcePacingWithoutVSync=0                                                                            ;    Whether to CPU pacers remain enabled even if VSync is off type=Int32 flags=RenderThreadSafe
r.Vulkan.ForceStagingBufferOnLock=0                                                                           ;    When nonzero, non-volatile buffer locks will always use staging buffers. Useful for debugging.\ndefault: 0 type=Int32 flags=RenderThreadSafe
r.Vulkan.IgnoreCPUReads=0                                                                                     ;    Debugging utility for GPU->CPU reads.\n 0 will read from the GPU (default).\n 1 will NOT read from the GPU and fill with zeros.\n type=Int32 flags=SetByConstructor
r.Vulkan.InputAttachmentShaderRead=0                                                                          ;    Whether to use VK_ACCESS_SHADER_READ_BIT an input attachments to workaround rendering issues\n0 use: VK_ACCESS_INPUT_ATTACHMENT_READ_BIT (default)\n1 use: VK_ACCESS_INPUT_ATTACHMENT_READ_BIT | VK_ACCESS_SHADER_READ_BIT\n type=Int32 flags=SetByConstructor
r.Vulkan.KeepSwapChain=1                                                                                      ;    Whether to keep old swap chain to pass through when creating the next one type=Int32 flags=RenderThreadSafe
r.Vulkan.LogEvictStatus=0                                                                                     ;    Log Eviction status every frame type=Int32 flags=RenderThreadSafe
r.Vulkan.MaxBarriersPerBatch=-1                                                                               ;    Will limit the number of barriers sent per batch\n <=0: Do not limit (default)\n >0: Limit to the specified number\n type=Int32 flags=SetByConstructor
r.Vulkan.MemoryBacktrace=10                                                                                   ;    0: Disable, store __FILE__ and __LINE__\nN: Enable, n is # of steps to go back\n type=Int32 flags=SetByConstructor
r.Vulkan.MemoryFallbackToHost=1                                                                               ;    0: Legacy, will crash when oom for rendertargets\n1: Fallback to Host memory on oom\n type=Int32 flags=SetByConstructor
r.Vulkan.MemoryMapChunkedPSOCache=true                                                                        ;    If true enabled memory mapping of the chunked vulkan PSO cache. (default)\n\n type=Boolean flags=RenderThreadSafe
r.Vulkan.PSOLRUEvictAfterUnusedFrames=0                                                                       ;    0: unused PSOs are not removed from the PSO LRU cache. (default)\n>0: The number of frames an unused PSO can remain in the PSO LRU cache. When this is exceeded the PSO is destroyed and memory returned to the system. This can save memory with the risk of increased hitching. type=Int32 flags=RenderThreadSafe
r.Vulkan.PipelineCacheCompression=1                                                                           ;    Enable/disable compression on the Vulkan pipeline cache disk file\n type=Int32 flags=RenderThreadSafe
r.Vulkan.PipelineCacheFromShaderPipelineCache=0                                                               ;    0 look for a pipeline cache in the normal locations with the normal names.1 tie the vulkan pipeline cache to the shader pipeline cache, use the PSOFC guid as part of the filename, etc. type=Int32 flags=SetByConstructor
r.Vulkan.PipelineCacheLoad=1                                                                                  ;    0 to disable loading the pipeline cache1 to enable using pipeline cache type=Int32 flags=SetByConstructor
r.Vulkan.PipelineDebugForceEvictImmediately=0                                                                 ;    1: Force all created PSOs to be evicted immediately. Only for debugging type=Int32 flags=RenderThreadSafe
r.Vulkan.PipelineLRUCacheEvictBinary=0                                                                        ;    0: create pipelines in from the binary PSO cache and binary shader cache and evict them only as it fills up.\n1: don't create pipelines....just immediately evict them type=Int32 flags=RenderThreadSafe
r.Vulkan.PipelineLRUCacheEvictBinaryPreloadScreen=0                                                           ;    1: Use a preload screen while loading preevicted PSOs ala r.Vulkan.PipelineLRUCacheEvictBinary type=Int32 flags=RenderThreadSafe
r.Vulkan.PipelineLRUCapactiy=8192                                                                             ;    Maximum no. of PSOs in LRU. type=Int32 flags=RenderThreadSafe
r.Vulkan.PipelineLRUSize=536870912                                                                            ;    Maximum size of shader memory . type=Int32 flags=RenderThreadSafe
r.Vulkan.PreTransform=1                                                                                       ;    0: Surface transformed in Vulkan Presentation Engine1: Surface transformed in App to save bandwidth (Default) type=Int32 flags=SetByConstructor
r.Vulkan.ProfileCmdBuffers=0                                                                                  ;    Insert GPU timing queries in every cmd buffer\n type=Int32 flags=SetByConstructor
r.Vulkan.RHIThread=1                                                                                          ;    0 to only use Render Thread\n1 to use ONE RHI Thread\n2 to use multiple RHI Thread\n type=Int32 flags=SetByConstructor
r.Vulkan.RayTracing=1                                                                                         ;    0: Do not enable Vulkan ray tracing extensions\n1: Enable experimental ray tracing support (default) type=Int32 flags=SetByConstructor
r.Vulkan.RayTracing.AllowCompaction=1                                                                         ;    Whether to automatically perform compaction for static acceleration structures to save GPU memory. (default = 1)\n type=Int32 flags=SetByConstructor
r.Vulkan.RayTracing.AllowDeferredOperation=0                                                                  ;    Whether to use Vulkan Deferred Operation for RT pipeline creation. (default = -1)\n <0: Disabled\n 0: Enabled, auto detect the maximum number of threads >0: Enabled, use the specified number of threads type=Int32 flags=SetByConstructor
r.Vulkan.RayTracing.MaxBatchedCompaction=64                                                                   ;    Maximum of amount of compaction requests and rebuilds per frame. (default = 64)\n type=Int32 flags=SetByConstructor
r.Vulkan.RayTracing.MaxShaderGroupStride=4096                                                                 ;    The default size to allocate for each record (default: 4096). type=Int32 flags=SetByConstructor
r.Vulkan.ReleaseShaderModuleWhenEvictingPSO=0                                                                 ;    0: shader modules remain when a PSO is removed from the PSO LRU cache. (default)\n1: shader modules are destroyed when a PSO is removed from the PSO LRU cache. This can save memory at the risk of increased hitching and cpu cost. type=Int32 flags=RenderThreadSafe
r.Vulkan.RobustBufferAccess=1                                                                                 ;    0 to disable robust buffer access1 to enable (default) type=Int32 flags=SetByConstructor
r.Vulkan.SingleAllocationPerResource=0                                                                        ;    Enable to do a single allocation per resource type=Int32 flags=RenderThreadSafe
r.Vulkan.SubmitAfterEveryEndRenderPass=0                                                                      ;    Forces a submit after every end render pass.\n 0: Don't(default)\n 1: Enable submitting type=Int32 flags=SetByConstructor
r.Vulkan.SubmitOcclusionBatchCmdBuffer=1                                                                      ;    1 to submit the cmd buffer after end occlusion query batch (default) type=Int32 flags=RenderThreadSafe
r.Vulkan.SubmitOnDispatch=0                                                                                   ;    0 to not do anything special on dispatch(default)\n1 to submit the cmd buffer after each dispatch type=Int32 flags=RenderThreadSafe
r.Vulkan.SubmitOnTextureUnlock=1                                                                              ;    Whether to submit upload cmd buffer on each texture unlock.\n 0: Do not submit\n 1: Submit (default) type=Int32 flags=SetByConstructor
r.Vulkan.SubmitOnTraceRays=0                                                                                  ;    0 to not do anything special on trace rays (default)\n1 to submit the cmd buffer after each trace rays type=Int32 flags=SetByConstructor
r.Vulkan.SwapChainIgnoreExtraImages=0                                                                         ;    Whether to ignore extra images created in swapchain and stick with a requested number of images type=Int32 flags=SetByConstructor
r.Vulkan.TempBlockSize=4194304                                                                                ;    Size of the temporary blocks allocate by contexts, used for single use ub allocs and copies (default: 4MB). type=Int32 flags=SetByConstructor
r.Vulkan.TimestampQueryStage=0                                                                                ;    Defines which pipeline stage is used for timestamp queries.\n 0: Use VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, less precise measures but less likely to alter performance (default)\n 1: Use VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, more precise measures but may alter performance on some platforms type=Int32 flags=RenderThreadSafe
r.Vulkan.UniqueValidationMessages=1                                                                           ;    Filter out validation errors with the same code (only when r.Vulkan.EnableValidation is non zero) type=Int32 flags=SetByConstructor
r.Vulkan.UploadCmdBufferSemaphore=0                                                                           ;    Whether command buffers for uploads and graphics can be executed simultaneously.\n 0: The buffers are submitted without any synch(default)\n 1: Graphics buffers will not overlap with the upload buffers type=Int32 flags=SetByConstructor
r.Vulkan.UseBufferBinning=0                                                                                   ;    Enable binning sub-allocations within buffers to help reduce fragmentation at the expense of higher high watermark [read-only]\n type=Int32 flags=SetByConstructor
r.Vulkan.UseChunkedPSOCache=0                                                                                 ;    \n type=Int32 flags=RenderThreadSafe
r.Vulkan.UseCmdBufferTimingForGPUTime=0                                                                       ;    Use the profile command buffers for GPU time\n type=Int32 flags=SetByConstructor
r.Vulkan.UseMemoryBarrierOpt=1                                                                                ;    Simplify buffer barriers and image barriers without layout transitions to a memory barrier.\n 0: Do not collapse to a single memory barrier, useful for tracking single resource transitions in external tools\n 1: Collapse to a memory barrier when appropriate (default) type=Int32 flags=SetByConstructor
r.Vulkan.UseProfileCheck=1                                                                                    ;    0 to assume all requested feature levels are supported.\n1 to verify feature level support using a profile check (default)\n type=Int32 flags=SetByConstructor
r.Vulkan.UseSingleQueue=0                                                                                     ;    Forces using the same queue for uploads and graphics.\n 0: Uses multiple queues(default)\n 1: Always uses the gfx queue for submissions type=Int32 flags=SetByConstructor
r.Vulkan.VRSFormat=0                                                                                          ;    Allows to choose the preferred Variable Rate Shading option. \n0: Prefer Fragment Shading Rate if both Fragment Shading Rate and Fragment Density Map are available.\n1: Use Fragment Shading Rate if available. A message will be reported if not available. \n2: Require Fragment Shading Rate. Will generate an error if the extension is not available. \n3: Prefer Fragment Density Map if both Fragment Shading Rate and Fragment Density Map are available.\n4: Use Fragment Density Map if available. A message will be reported if not available.\n5: Require Fragment Density Map. Will generate an error if the extension is not available. type=Int32 flags=SetByConstructor
r.Vulkan.WaitForIdleOnSubmit=0                                                                                ;    Waits for the GPU to be idle after submitting a command buffer. Useful for tracking GPU hangs.\n 0: Do not wait(default)\n 1: Wait on every submit\n 2: Wait when submitting an upload buffer\n 3: Wait when submitting an active buffer (one that has gfx commands)\n type=Int32 flags=SetByConstructor
r.XeFG.Active=true                                                                                            ;    If XeFG is active, it should help prevent conflicts with other similar plugins. type=Boolean flags=SetByConstructor
r.XeFG.ClearSceneColorAlpha=1                                                                                 ;    [default: 1] if clear scene color alpha value. type=Int32 flags=SetByConstructor
r.XeFG.Enabled=0                                                                                              ;    [default: 0] Set to 1 to enable XeFG. type=Int32 flags=SetByConstructor
r.XeFG.LogLevel=1                                                                                             ;    [default: 1] Minimum log level of XeFG SDK, set it via command line -XeFGLogLevel= 0: debug, 1: info, 2: warning, 3: error, 4: off. type=Int32 flags=SetByConstructor
r.XeFG.MotionVectorScale=1.0                                                                                  ;    [default: 1.0f] Scale applied to motion vector. type=Float flags=SetByConstructor
r.XeFG.OverrideSwapChain=false                                                                                ;    [default: true] If override swap chain, it should help prevent conflicts with other similar plugins. type=Boolean flags=SetByScalability|SetByGameSetting|SetByProjectSetting
r.XeFG.ResourceValidity=1                                                                                     ;    [default: 1] Validity of input resources of XeFG, set it via command line -XeFGResourceValidity= 0: XEFG_SWAPCHAIN_RV_UNTIL_NEXT_PRESENT, 1: XEFG_SWAPCHAIN_RV_ONLY_NOW. type=Int32 flags=SetByConstructor
r.XeFG.Supported=true                                                                                         ;    If XeFG is supported. type=Boolean flags=SetByScalability|SetBySystemSettingsIni|SetByDeviceProfile|SetByCommandLine|SetByCode
r.XeFG.TagUI=1                                                                                                ;    [default: 1] Tag UI color and alpha. type=Int32 flags=RenderThreadSafe
r.XeFG.TagUIAlphaThreshold=0.0                                                                                ;    [default: 0.0] UI extraction pass alpha threshold value. type=Float flags=RenderThreadSafe
r.XeFG.UIMode=5                                                                                               ;    [default: 5] UI mode. 0: auto based on provided inputs, 1: without any UI handling, 2: refine UI using UI texture + alpha, 3: blend UI from UI texture + alpha, 4: extract UI from backbuffer, 5: blend UI from UI texture + alpha and refine it by extracting from backbuffer. type=Int32 flags=SetByConstructor
r.XeFG.Version=XeFG version: 1.2.0                                                                            ;    Show XeFG SDK's version. type=String flags=SetByScalability|SetBySystemSettingsIni|SetByDeviceProfile|SetByCommandLine|SetByCode
r.d3d.uniformbufferrecycledepth=30                                                                            ;    Number of frames before recycling freed uniform buffers .\n type=Int32 flags=SetByConstructor
r.gpucrash.collectionenable=1                                                                                 ;    Stores GPU crash data from scoped events when a applicable crash debugging system is available. type=Int32 flags=RenderThreadSafe
r.gpucrash.datadepth=-1                                                                                       ;    Limits the amount of marker scope depth we record for GPU crash debugging to the given scope depth. type=Int32 flags=RenderThreadSafe
r.vulkan.LogDefrag=0                                                                                          ;    Whether to log all defrag moves & evictions\n0: Off\n1: On\n type=Int32 flags=SetByConstructor
rhi.Bindless.Resources=Disabled                                                                               ;    Set to Enabled to enable for all shader types. Set to RayTracingOnly to restrict to Raytracing shaders. type=String flags=SetByConstructor
rhi.Bindless.Samplers=Disabled                                                                                ;    Set to Enabled to enable for all shader types. Set to RayTracingOnly to restrict to Raytracing shaders. type=String flags=SetByConstructor
rhi.EnableConsole120Fps=0                                                                                     ;    Enable Console 120fps if Monitor supports it and Console is properly setup type=Int32 flags=SetByConstructor
rhi.PresentThreshold.Bottom=0.0                                                                               ;    Specifies the percentage of the screen from the bottom where tearing is allowed.\nOnly effective on supported platforms.\nRange: 0.0 - 1.0\n type=Float flags=SetByConstructor
rhi.PresentThreshold.Top=0.0                                                                                  ;    Specifies the percentage of the screen from the top where tearing is allowed.\nOnly effective on supported platforms.\nRange: 0.0 - 1.0\n type=Float flags=SetByConstructor
rhi.SyncAllowEarlyKick=1                                                                                      ;    When 1, allows the RHI vsync thread to kick off the next frame early if we've missed the vsync. type=Int32 flags=SetByConstructor
rhi.SyncAllowVariable=1                                                                                       ;    When 1, allows the RHI to use variable refresh rate, if supported by the output hardware. type=Int32 flags=SetByConstructor
rhi.SyncInterval=1                                                                                            ;    Determines the frequency of VSyncs in supported RHIs.\nThis is in multiples of 16.66 on a 60hz display, but some platforms support higher refresh rates.\nAssuming 60fps, the values correspond to:\n  0 - Unlocked (present immediately)\n  1 - Present every vblank interval\n  2 - Present every 2 vblank intervals\n  3 - etc...\n type=Int32 flags=SetByConstructor
rhi.SyncSlackMS=10.0                                                                                          ;    Increases input latency by this many milliseconds, to help performance (trade-off tunable). Gamethread will be kicked off this many milliseconds before the vsync type=Float flags=SetByConstructor
rhi.UseSubmissionThread=2                                                                                     ;    Whether to enable the RHI submission thread.\n  0: No\n  1: Yes, but not when running with multi-gpu.\n  2: Yes, always\n type=Int32 flags=SetByConstructor
